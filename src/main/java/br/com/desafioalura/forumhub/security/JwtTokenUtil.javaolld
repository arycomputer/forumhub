package br.com.desafioalura.forumhub.security;

// src/main/java/com/example/demo/security/JwtTokenUtil.java

import com.auth0.jwt.JWT;
import com.auth0.jwt.JWTVerifier;
import com.auth0.jwt.algorithms.Algorithm;
import com.auth0.jwt.exceptions.JWTVerificationException;
import com.auth0.jwt.interfaces.DecodedJWT;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.stereotype.Component;

import java.io.Serializable;
import java.util.Date;
import java.util.HashMap;
import java.util.Map;

@Component
public class JwtTokenUtil implements Serializable {

    private static final long serialVersionUID = -2550185165626007488L;

    public static final long JWT_TOKEN_VALIDITY = 5 * 60 * 60 * 1000; // 5 horas em milissegundos

    @Value("${jwt.secret}")
    private String secret;

    private Algorithm algorithm;

    // Inicializa o algoritmo de assinatura com a chave secreta
    private Algorithm getAlgorithm() {
        if (this.algorithm == null) {
            this.algorithm = Algorithm.HMAC512(secret);
        }
        return this.algorithm;
    }

    // Recupera o email do token JWT (o subject do token)
    public String getEmailFromToken(String token) {
        try {
            DecodedJWT jwt = JWT.decode(token);
            return jwt.getSubject();
        } catch (JWTVerificationException e) {
            // Log the exception for debugging
            System.out.println("Erro ao decodificar o token para obter o email: " + e.getMessage());
            return null;
        }
    }

    // Recupera a data de expiração do token JWT
    public Date getExpirationDateFromToken(String token) {
        try {
            DecodedJWT jwt = JWT.decode(token);
            return jwt.getExpiresAt();
        } catch (JWTVerificationException e) {
            // Log the exception for debugging
            System.out.println("Erro ao decodificar o token para obter a data de expiração: " + e.getMessage());
            return null;
        }
    }
//    // Gera token para o utilizador, incluindo a função (role)
//    public String generateToken(UserDetails userDetails, String role) {
//        return JWT.create()
//                .withSubject(userDetails.getUsername()) // O email é o username para UserDetails
//                .withClaim("role", role) // Adiciona a função como uma claim
//                .withIssuedAt(new Date(System.currentTimeMillis()))
//                .withExpiresAt(new Date(System.currentTimeMillis() + JWT_TOKEN_VALIDITY))
//                .sign(getAlgorithm());
//    }


//    public String generateToken(UserDetails userDetails, String role) {
//        Map<String, Object> claims = new HashMap<>();
//        claims.put("role", role); // ✅ inclui a role no token
//
//        return JWT.builder()
//                .setClaims(claims)
//                .setSubject(userDetails.getUsername())
//                .setIssuedAt(new Date())
//                .setExpiration(new Date(System.currentTimeMillis() + expiration)) // ex: 24h
//                .signWith(SignatureAlgorithm.HS512, secret)
//                .compact();
//    }

    public String generateToken(UserDetails userDetails, String role) {
        Map<String, Object> claims = new HashMap<>();
        claims.put("role", role); // adiciona a role

        return JWT.create()
                .withClaim("role", role)
               // .setClaims(claims)
                .withSubject(userDetails.getUsername())
                //.setSubject(userDetails.getUsername())
                .withIssuedAt(new Date(System.currentTimeMillis()))
              //  .setIssuedAt(new Date(System.currentTimeMillis()))
                .withExpiresAt(new Date(System.currentTimeMillis() + expiration))
               // .setExpiration(new Date(System.currentTimeMillis() + expiration)) // ex: 24h
                .sign(getAlgorithm())
               // .signWith(SignatureAlgorithm.HS512, secret)
                .compact();
    }




//    // Gera token para o utilizador
//    public String generateToken(UserDetails userDetails) {
//        return JWT.create()
//                .withSubject(userDetails.getUsername()) // O email é o username para UserDetails
//                .withIssuedAt(new Date(System.currentTimeMillis()))
//                .withExpiresAt(new Date(System.currentTimeMillis() + JWT_TOKEN_VALIDITY))
//                .sign(getAlgorithm());
//    }

    // Valida o token
    public Boolean validateToken(String token, UserDetails userDetails) {
        final String email = getEmailFromToken(token);
        try {
            // Tenta verificar a assinatura e a expiração do token
            JWTVerifier verifier = JWT.require(getAlgorithm()).withSubject(userDetails.getUsername()).build();
            verifier.verify(token);
            // Se a verificação for bem-sucedida, o token é válido e não expirou
            return email != null && email.equals(userDetails.getUsername());
        } catch (JWTVerificationException e) {
            // Token inválido ou expirado
            System.out.println("Falha na validação do token: " + e.getMessage());
            return false;
        }
    }
}
